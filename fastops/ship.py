"""The orchestrator: detect → build → proxy → deploy"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/13_ship.ipynb.

# %% auto #0
__all__ = ['ship']

# %% ../nbs/13_ship.ipynb
from pathlib import Path
from .detect import detect, auto_dockerfile
from .compose import Compose, service
from .compliance import harden_dockerfile, harden_service, compliance_cmds, logging_svc, soc2_defaults, hipaa_defaults, iso27001_defaults
from .proxy import Caddyfile, NginxConf
from .apps import python_app, fasthtml_app, fastapi_react, go_app, rust_app

# %% ../nbs/13_ship.ipynb
_BUILDERS = {
    'python': python_app,
    'fasthtml': fasthtml_app,
    'fastapi': lambda **kw: python_app(cmd=['uvicorn', 'main:app', '--host', '0.0.0.0', f'--port={kw.get("port", 8000)}'], **kw),
    'fastapi-react': fastapi_react,
    'flask': lambda **kw: python_app(cmd=['flask', 'run', '--host=0.0.0.0', f'--port={kw.get("port", 5000)}'], **kw),
    'go': go_app,
    'rust': rust_app,
}

# %% ../nbs/13_ship.ipynb
def ship(path='.', *, to='docker', domain=None, port=None, proxy='caddy', 
         preset='production', tls=True, tunnel=False, security=False, 
         compliance=None, host=None, user='deploy', key=None, cloud=None, resources=None):
    'Main orchestrator: detect → build → proxy → deploy'
    
    result = {
        'status': 'started',
        'path': str(Path(path).absolute()),
    }
    
    # Step 1: Detect
    print(f'Detecting framework in {path}...')
    info = detect(path)
    result['language'] = info['language']
    result['framework'] = info['framework']
    result['detected_port'] = info['port']
    
    # Use detected port if not specified
    app_port = port or info['port'] or 8080
    result['port'] = app_port
    
    # Step 2: Generate Dockerfile
    print(f'Generating Dockerfile for {info["framework"] or info["language"]}...')
    dockerfile_path = Path(path) / 'Dockerfile'
    
    if dockerfile_path.exists():
        print('Using existing Dockerfile')
        from .core import Dockerfile
        df = Dockerfile.load(dockerfile_path)
    else:
        # Use auto_dockerfile or builder
        framework = info['framework'] or info['language']
        if framework in _BUILDERS:
            df = _BUILDERS[framework](port=app_port)
        else:
            df, framework = auto_dockerfile(path, app_port)
        
        # Apply compliance hardening to Dockerfile
        if compliance:
            print(f'Applying {compliance} compliance hardening to Dockerfile...')
            df = harden_dockerfile(df, port=app_port)
        
        df.save(dockerfile_path)
    
    result['dockerfile'] = str(dockerfile_path)
    
    # Step 3: Build Compose
    print('Building docker-compose configuration...')
    compose = Compose()
    
    # Process resources first if provided
    resource_env = {}
    if resources:
        print('Provisioning resources...')
        from .resources import stack
        
        # Determine effective provider based on deployment target
        resource_provider = 'docker'
        if to in ('azure', 'aws', 'gcp'):
            resource_provider = to
        
        # Build resource stack with the appropriate provider
        # Wrap each resource function to apply provider
        provider_resources = {}
        for res_name, res_fn in resources.items():
            # Create a wrapper that calls the function and applies the provider
            def wrapper(fn=res_fn, prov=resource_provider):
                return fn() if callable(fn) else fn
            provider_resources[res_name] = wrapper
        
        # Get resources environment, compose services, and volumes
        res_env, res_dc, res_vols = stack(provider_resources, provider=resource_provider)
        
        # Merge resource environment variables
        resource_env.update(res_env)
        
        # Merge resource services into main compose
        for item in res_dc:
            compose = compose._add(item)
    
    # App service with resource environment
    app_name = Path(path).name or 'app'
    app_svc = service(
        build='.',
        ports={app_port: app_port}
    )
    
    # Add resource environment to app service
    if resource_env:
        app_svc['environment'] = resource_env
    
    # Load compliance defaults if specified
    compliance_config = {}
    if compliance == 'soc2':
        compliance_config = soc2_defaults()
    elif compliance == 'hipaa':
        compliance_config = hipaa_defaults()
    elif compliance == 'iso27001':
        compliance_config = iso27001_defaults()
    
    # Apply service hardening
    if compliance_config.get('harden_services'):
        print('Hardening service configuration...')
        app_svc = harden_service(app_svc, tmpfs=['/tmp'])
    
    compose = compose.svc(app_name, **app_svc)
    
    # Add logging if compliance requires it
    if compliance_config.get('logging'):
        print(f'Adding {compliance_config["logging"]} logging...')
        log_svc = logging_svc(compliance_config['logging'])
        compose = compose.svc('logging', **log_svc)
    
    # Add proxy if domain specified
    if domain:
        result['domain'] = domain
        
        if proxy == 'caddy':
            print(f'Configuring Caddy reverse proxy for {domain}...')
            caddyfile = Caddyfile(domain, app_name, app_port)
            
            # Apply preset
            if preset == 'production':
                caddyfile = caddyfile.production()
            elif preset == 'spa':
                caddyfile = caddyfile.spa()
            elif preset == 'api':
                caddyfile = caddyfile.api()
            
            # Add tunnel support
            if tunnel:
                caddyfile = caddyfile.cloudflared()
            
            # Add CrowdSec if compliance requires
            if compliance_config.get('crowdsec'):
                print('Adding CrowdSec protection...')
                caddyfile = caddyfile.crowdsec()
            
            caddyfile.save(Path(path) / 'Caddyfile')
            
            # Add Caddy service
            caddy_svc = service(
                image='caddy:latest',
                volumes={
                    './Caddyfile': '/etc/caddy/Caddyfile',
                    'caddy_data': '/data',
                    'caddy_config': '/config'
                },
                depends_on=[app_name],
                restart='unless-stopped'
            )
            
            if not tunnel:
                caddy_svc['ports'] = {443: 443, 80: 80}
            
            compose = compose.svc('caddy', **caddy_svc)
            compose = compose.volume('caddy_data')
            compose = compose.volume('caddy_config')
        
        elif proxy == 'nginx' or proxy == 'swag':
            print(f'Configuring nginx reverse proxy for {domain}...')
            nginx_conf = NginxConf(domain, app_name, app_port)
            
            # Apply preset
            if preset == 'production':
                nginx_conf = nginx_conf.production()
            elif preset == 'api':
                nginx_conf = nginx_conf.api()
            elif preset == 'realtime':
                nginx_conf = nginx_conf.realtime()
            
            nginx_conf.save(Path(path) / 'proxy.conf')
            
            # Add SWAG service (nginx-based)
            from .compose import swag
            swag_svc = swag(domain, app_name, app_port, cloudflared=tunnel)
            compose = compose.svc('swag', **swag_svc)
            compose = compose.volume('swag_config')
            compose = compose.network('web')
    
    # Save compose file
    compose_path = Path(path) / 'docker-compose.yml'
    compose.save(compose_path)
    result['compose'] = str(compose_path)
    
    # Step 4: Deploy
    if to == 'docker':
        print('Deploying to local Docker...')
        compose.up(detach=True, path=compose_path)
        result['status'] = 'deployed'
        result['target'] = 'docker'
        result['url'] = f'http://localhost:{app_port}'
    
    elif to == 'vps':
        if not host:
            raise ValueError('host parameter required for VPS deployment')
        
        print(f'Deploying to VPS {host}...')
        from .vps import deploy
        
        # Deploy using existing vps.py deploy function
        deploy_result = deploy(
            host=host,
            user=user,
            key=key,
            path=path,
            compliance=compliance
        )
        result['status'] = 'deployed'
        result['target'] = 'vps'
        result['host'] = host
        result['url'] = f'https://{domain}' if domain else f'http://{host}:{app_port}'
    
    elif to == 'azure':
        print('Deploying to Azure...')
        from .azure import azure_stack
        
        # Build and push image if needed
        image_name = f'{app_name}:latest'
        
        azure_result = azure_stack(
            app_name=app_name,
            image=image_name,
            port=app_port,
            postgres='postgres' in str(df).lower(),
            registry=True
        )
        
        result['status'] = 'deployed'
        result['target'] = 'azure'
        result['azure'] = azure_result
        result['url'] = azure_result.get('app_url')
    
    elif to == 'aws':
        print('Deploying to AWS...')
        from .aws import aws_stack
        
        image_name = f'{app_name}:latest'
        
        aws_result = aws_stack(
            app_name=app_name,
            region=cloud or 'us-east-1',
            image=image_name,
            port=app_port,
            postgres='postgres' in str(df).lower(),
            registry=True
        )
        
        result['status'] = 'deployed'
        result['target'] = 'aws'
        result['aws'] = aws_result
    
    else:
        result['status'] = 'error'
        result['error'] = f'Unknown deployment target: {to}'
    
    # Add compliance info
    if compliance:
        result['compliance_level'] = compliance
        result['compliance_config'] = compliance_config
    
    print(f'\n✅ Deployment complete!')
    print(f'   Framework: {result["framework"] or result["language"]}')
    print(f'   Port: {result["port"]}')
    if result.get('url'):
        print(f'   URL: {result["url"]}')
    
    return result
